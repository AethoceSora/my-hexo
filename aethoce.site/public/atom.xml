<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aethoce&#39;s Blog</title>
  
  <subtitle>为开放自由的互联网做点微小的贡献</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-13T01:14:16.822Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jinghong Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能计算-基准测试程序Linpack（HPL）</title>
    <link href="http://example.com/2022/12/11/HPL/"/>
    <id>http://example.com/2022/12/11/HPL/</id>
    <published>2022-12-11T02:48:16.705Z</published>
    <updated>2022-12-13T01:14:16.822Z</updated>
    
    <content type="html"><![CDATA[<p>自通用计算机时代开始以来，就出现了各种用于评估计算机性能的基准测试程序。这些程序的性质通常反映了构建计算机的预期目的，同时还提供了可以与制造商的理论性能估计进行比较的经验性能测量。</p><p>高性能计算中最广泛使用的基准之一就是Linpack基准，它的起源是一个线性代数运算包，后来被Lapack库和其他竞争对手取代。但Linpack的基准测试程序在以后的日子里继续发挥强大的影响力。</p><p>HPL，即(High-Performance <em>Linpack</em>)是早期Linpack的衍生产品，其高度并行化的设计，使得它用于评估TOP500超级计算机的性能排名。</p><h2 id="编译安装HPL"><a href="#编译安装HPL" class="headerlink" title="编译安装HPL"></a>编译安装HPL</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>在安装HPL之前，系统上需要安装好支持C语言和Fortran77语言的编译器，我个人选择使用gcc与gfortran ，我将用他们来安装BLAS、MPICH以及HPL本体。</p><h4 id="BLAS"><a href="#BLAS" class="headerlink" title="BLAS"></a>BLAS</h4><p>到<a href="http://www.netlib.org/blas/">BLAS官网</a>下载好源码，使用tar指令解压。进入BLAS文件夹，执行编译指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gfortran -c -O3 *.f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译所有的 .f 文件，生成 .o文件</span></span><br><span class="line"> </span><br><span class="line">ar rv libblas.a *.o  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">链接所有的 .o文件，生成.a 文件</span></span><br><span class="line"> </span><br><span class="line">cp libblas.a /usr/local/lib  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将库文件复制到系统库目录</span></span><br></pre></td></tr></table></figure><h4 id="MPICH"><a href="#MPICH" class="headerlink" title="MPICH"></a>MPICH</h4><p>到<a href="https://www.mpich.org/downloads/">MPICH官网</a>下载源码包，使用tar指令解压。进入mpich文件夹进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/software/mpich-4.0.3</span><br></pre></td></tr></table></figure><p>然后<code>make&amp;&amp;make install</code>完成安装。</p><p>记得编辑<code>.bashrc</code>以配置环境变量。可参考下方配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mpich</span><br><span class="line"></span><br><span class="line">export MPI_HOME=/home/software/mpich-4.0.3</span><br><span class="line"></span><br><span class="line">export PATH=$MPI_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$MPI_HOME/include</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MPI_HOME/lib</span><br><span class="line"></span><br><span class="line">export MANPATN=$MANPATH:$MPI_HOME/man</span><br></pre></td></tr></table></figure><p>最后激活环境变量即可使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><h4 id="HPL"><a href="#HPL" class="headerlink" title="HPL"></a>HPL</h4><p>于<a href="https://netlib.org/benchmark/hpl/">HPL官网</a>下载源码包，使用<code>tar</code>指令解压后进入其<code>setup</code>目录。</p><p>手写Make文件是一件痛苦的事情，好在这里有一些针对各种体系结构的编译设置实例。对于此实例，我们需要执行<code>make_generic</code>脚本以生成用于创建编译设置的模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd hpl-2.3/setup</span><br><span class="line">sh make_generic</span><br><span class="line">cp Make.UNKNOWN ..Make.linux</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>现在，我们需要修改<code>Make.linux</code>文件，以声明hpl2.3目录以及BLAS库的位置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 LAlib= -lblas</span><br></pre></td></tr></table></figure><p>使用-L标志为编译器提供库位置，例如我的BLAS库安装在<code>/usr/local/lib</code>中，则将97行更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 LAlib= -L/usr/local/lib -lblas</span><br></pre></td></tr></table></figure><p>另外在第70行指定<code>hpl-2.3</code>目录的位置，在64行将架构体系的名称从UNKNOWN改为linux</p><p>准备好<code>Make.linux</code>文件后，发出以下指令来编译HPL。</p><p><code>make arch=linux</code></p><p>这将在<code>bin/linux</code>目录里创建HPL的可执行文件xhpl。</p><h3 id="调试HPL参数文件"><a href="#调试HPL参数文件" class="headerlink" title="调试HPL参数文件"></a>调试HPL参数文件</h3><p>伴随<code>xhpl</code>可执行文件的是一个参数文件(HPL.dat)，用于调整HPL的计算参数。</p><p>下面给出一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">HPLinpack benchmark input file</span><br><span class="line">Innovative Computing Laboratory, University of Tennessee</span><br><span class="line">HPL.out      output file name (if any)</span><br><span class="line">6            device out (6=stdout,7=stderr,file)</span><br><span class="line">1            # of problems sizes (N)</span><br><span class="line">143360 256000 1000         Ns  </span><br><span class="line">1            # of NBs</span><br><span class="line">384 192 256      NBs </span><br><span class="line">1            PMAP process mapping (0=Row-,1=Column-major)</span><br><span class="line">1            # of process grids (P x Q)</span><br><span class="line">1 2          Ps  </span><br><span class="line">1 2          Qs  </span><br><span class="line">16.0         threshold</span><br><span class="line">1            # of panel fact</span><br><span class="line">2 1 0        PFACTs (0=left, 1=Crout, 2=Right)</span><br><span class="line">1            # of recursive stopping criterium</span><br><span class="line">2            NBMINs (&gt;= 1)</span><br><span class="line">1            # of panels in recursion</span><br><span class="line">2            NDIVs</span><br><span class="line">1            # of recursive panel fact.</span><br><span class="line">1 0 2        RFACTs (0=left, 1=Crout, 2=Right)</span><br><span class="line">1            # of broadcast</span><br><span class="line">0            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)</span><br><span class="line">1            # of lookahead depth</span><br><span class="line">0            DEPTHs (&gt;=0)</span><br><span class="line">0            SWAP (0=bin-exch,1=long,2=mix)</span><br><span class="line">1            swapping threshold</span><br><span class="line">1            L1 in (0=transposed,1=no-transposed) form</span><br><span class="line">1            U  in (0=transposed,1=no-transposed) form</span><br><span class="line">0            Equilibration (0=no,1=yes)</span><br><span class="line">8            memory alignment in double (&gt; 0)</span><br></pre></td></tr></table></figure><p>测试过程中您可以根据节点的硬件配置，调整HPL.dat文件中相关参数，参数的说明如下所示。</p><ul><li><p>第5~6行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1            # of problems sizes (N)，N表示求解的矩阵数量与规模</span><br><span class="line">143360 256000 1000         Ns  </span><br></pre></td></tr></table></figure><p>N表示求解的矩阵数量与规模。矩阵规模N越大，有效计算所占的比例也越大，系统浮点处理性能也就越高。但矩阵规模越大会导致内存消耗量越多，如果系统实际内存空间不足，使用缓存、性能会大幅度降低。矩阵占用系统总内存的80%左右为最佳，即N×N×8&#x3D;系统总内存×80%（其中总内存的单位为字节）。</p></li><li><p>第7~8行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1            # of NBs，NB表示求解矩阵过程中矩阵分块的大小</span><br><span class="line">384 192 256      NBs </span><br></pre></td></tr></table></figure><p>求解矩阵过程中矩阵分块的大小。分块大小对性能有很大的影响，NB的选择和软硬件许多因素密切相关。NB值的选择主要是通过实际测试得出最优值，一般遵循以下规律：</p><ul><li>NB不能太大或太小，一般小于384。</li><li>NB×8一定是缓存行的倍数。</li><li>NB的大小和通信方式、矩阵规模、网络、处理器速度等有关系。</li></ul><p>一般通过单节点或单CPU测试可以得到几个较好的NB值，但当系统规模增加、问题规模变大，有些NB取值所得性能会下降。因此建议在小规模测试时选择3个性能不错的NB值，再通过大规模测试检验这些选择。</p></li><li><p>第10~12行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1            # of process grids (P x Q)，P表示水平方向处理器个数，Q表示垂直方向处理器个数</span><br><span class="line">1 2          Ps  </span><br><span class="line">1 2          Qs  </span><br></pre></td></tr></table></figure><p>P表示水平方向处理器个数，Q表示垂直方向处理器个数。P×Q表示二维处理器网格。P×Q&#x3D;系统CPU数&#x3D;进程数。一般情况下一个进程对应一个CPU，可以得到最佳性能。对于Intel ® Xeon ®，关闭超线程可以提高HPL性能。P和Q的取值一般遵循以下规律：</p><ul><li>P≤Q，一般情况下P的取值小于Q，因为列向通信量（通信次数和通信数据量）要远大于横向通信。</li><li>P建议选择2的幂。HPL中水平方向通信采用二元交换法（Binary Exchange），当水平方向处理器个数P为2的幂时性能最优。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自通用计算机时代开始以来，就出现了各种用于评估计算机性能的基准测试程序。这些程序的性质通常反映了构建计算机的预期目的，同时还提供了可以与制造商的理论性能估计进行比较的经验性能测量。&lt;/p&gt;
&lt;p&gt;高性能计算中最广泛使用的基准之一就是Linpack基准，它的起源是一个线性代数</summary>
      
    
    
    
    
    <category term="High Performance Computing" scheme="http://example.com/tags/High-Performance-Computing/"/>
    
  </entry>
  
  <entry>
    <title>QLUT镜像站的日志监控及预警方案</title>
    <link href="http://example.com/2022/12/07/Graf/"/>
    <id>http://example.com/2022/12/07/Graf/</id>
    <published>2022-12-06T17:27:20.000Z</published>
    <updated>2022-12-24T15:39:11.541Z</updated>
    
    <content type="html"><![CDATA[<p>十分意外镜像站用户增长速度如此之快，面对日均五万左右的用户量，服务器频繁出现各种性能问题。在故障排查的过程中，我意识到服务器需要一套成熟、完整、可靠的日志监控及预警方案。</p><p>先前长期使用 <code>goaccess</code> 静态分析Nginx的日志，具有滞后性。只能用于单纯的分析总结一段时间内的网站流量状况，而无法做到实时监看服务状态和运行数据。</p><p>既然是开源镜像站，那么我们就需要把目光投向开源社区。</p><h2 id="较为流行的ELK"><a href="#较为流行的ELK" class="headerlink" title="较为流行的ELK"></a>较为流行的ELK</h2><p>目前市面上最流行的日志处理方案莫过于“ELK”系统，“ELK”是Elasticsearch、Logstash和Kibana的组合的合称。</p><p>Elasticsearch 是一个搜索和分析引擎。Logstash 是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中。Kibana 则可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化。</p><h2 id="InfluxDB-amp-Telegraf"><a href="#InfluxDB-amp-Telegraf" class="headerlink" title="InfluxDB&amp;Telegraf"></a>InfluxDB&amp;Telegraf</h2><p>通过自己的初步了解以及咨询使用者的使用体验，我认为ELK在使用体验和性能上都不适合我（其实是单纯的不喜欢Java）。而一个朋友推荐我去尝试一下 InfluxDB+Telegraf 的组合。</p><p>服务器的性能日志从本质上来说，属于<strong>时序大数据</strong>，我们打开数据库排名网站<a href="https://db-engines.com/en/ranking">DB-Engines Ranking</a>，左侧选择时序数据库(<a href="https://db-engines.com/en/ranking/time+series+dbms">Time Series DBMS</a>)，可以看到 InfluxDB 在排名上一骑绝尘。</p><p><img src="https://s2.loli.net/2022/12/24/e8RbQm7i2Jj1Kzk.png" alt="image.png"></p><p>安装直接跟着官方文档即可，下面我将英文文档翻译一下给大家参考：</p><h4 id="使用-systemd-将-InfluxDB-安装为服务"><a href="#使用-systemd-将-InfluxDB-安装为服务" class="headerlink" title="使用 systemd 将 InfluxDB 安装为服务"></a>使用 systemd 将 InfluxDB 安装为服务</h4><ol><li><p>使用以下命令从<a href="https://portal.influxdata.com/downloads/">InfluxData 下载页面</a>使用 URL 下载并安装适当的<code>.deb</code>或文件：<code>.rpm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb2-2.6.0-xxx.deb</span><br><span class="line">sudo dpkg -i influxdb2-2.6.0-xxx.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># Red Hat/CentOS/Fedora</span></span><br><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb2-2.6.0-xxx.rpm</span><br><span class="line">sudo yum localinstall influxdb2-2.6.0-xxx.rpm</span><br></pre></td></tr></table></figure><p><em>使用<code>.rpm</code>包下载的确切文件名（例如，<code>influxdb2-2.6.0-amd64.rpm</code>）。</em></p></li><li><p>启动 InfluxDB 服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service influxdb start</span><br></pre></td></tr></table></figure><p>安装 InfluxDB 包会创建一个服务文件，<code>/lib/systemd/system/influxdb.service</code> 用于在启动时将 InfluxDB 作为后台服务启动。</p></li><li><p>重新启动系统并验证服务是否正常运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> sudo service influxdb status</span></span><br><span class="line">● influxdb.service - InfluxDB is an open-source, distributed, time series database</span><br><span class="line">  Loaded: loaded (/lib/systemd/system/influxdb.service; enabled; vendor preset: enable&gt;</span><br><span class="line">  Active: active (running)</span><br></pre></td></tr></table></figure></li></ol><p>有关 InfluxDB 在作为服务运行时在磁盘上存储数据的位置的信息，请参阅<a href="https://docs.influxdata.com/influxdb/v2.6/reference/internals/file-system-layout/?t=Linux#installed-as-a-package">文件系统布局</a>。</p><p>要自定义 InfluxDB 配置，请使用 <a href="https://docs.influxdata.com/influxdb/v2.6/install/?t=Linux#pass-arguments-to-systemd">命令行标志（参数）</a>、环境变量或 InfluxDB 配置文件。有关详细信息，请参阅 InfluxDB<a href="https://docs.influxdata.com/influxdb/v2.6/reference/config-options/">配置选项</a>。</p><h4 id="将参数传递给-systemd"><a href="#将参数传递给-systemd" class="headerlink" title="将参数传递给 systemd"></a>将参数传递给 systemd</h4><ol><li><p>添加一行或多行命令，如下所示，包含<code>influxd</code>to的参数<code>/etc/default/influxdb2</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG1=<span class="string">&quot;--http-bind-address :8087&quot;</span></span><br><span class="line">ARG2=<span class="string">&quot;&lt;another argument here&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>编辑<code>/lib/systemd/system/influxdb.service</code>文件如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/influxd <span class="variable">$ARG1</span> <span class="variable">$ARG2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="启动-InfluxDB"><a href="#启动-InfluxDB" class="headerlink" title="启动 InfluxDB"></a>启动 InfluxDB</h4><p>如果 InfluxDB 作为 systemd 服务安装，则 systemd 管理<code>influxd</code>守护进程，不需要进一步的操作。如果二进制文件是手动下载并添加到系统中的，请使用以下命令<code>$PATH</code>启动守护进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influxd</span><br></pre></td></tr></table></figure><p>进入8086端口配置好后，就可以在DashBoard里查阅可视化数据了。</p><p><img src="https://s2.loli.net/2022/12/24/2ybGTCxF6znZQJA.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;十分意外镜像站用户增长速度如此之快，面对日均五万左右的用户量，服务器频繁出现各种性能问题。在故障排查的过程中，我意识到服务器需要一套成熟、完整、可靠的日志监控及预警方案。&lt;/p&gt;
&lt;p&gt;先前长期使用 &lt;code&gt;goaccess&lt;/code&gt; 静态分析Nginx的日志，具有</summary>
      
    
    
    
    
    <category term="Devops" scheme="http://example.com/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>记录镜像站遭遇SYN泛洪攻击的诊断与防御</title>
    <link href="http://example.com/2022/12/06/SYN/"/>
    <id>http://example.com/2022/12/06/SYN/</id>
    <published>2022-12-06T02:36:01.023Z</published>
    <updated>2022-12-24T09:39:26.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常的连接数"><a href="#异常的连接数" class="headerlink" title="异常的连接数"></a>异常的连接数</h2><p>近日，镜像站莫名遭到多次攻击，症状表现为TCP连接数异常上升，久久得不到释放。后台监控检测到大量5XX错误，CPU负载高，正常业务受到较大影响。</p><p>通过使用netstat命令可以统计服务器当前的各种TCP状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>我站在受攻击时的状态列表如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TIME_WAIT 168</span><br><span class="line">CLOSE_WAIT 9</span><br><span class="line">SYN_SENT 3</span><br><span class="line">FIN_WAIT1 229</span><br><span class="line">FIN_WAIT2 113</span><br><span class="line">ESTABLISHED 234</span><br><span class="line">SYN_RECV 1272</span><br><span class="line">CLOSING 3</span><br><span class="line">LAST_ACK 97</span><br></pre></td></tr></table></figure><p>可以明显发现SYN_RECV连接数异常增多。</p><p>仅通过这一现象就可以判断为服务器受到了SYN Flood泛洪攻击。</p><h2 id="SYN-Flood泛洪攻击"><a href="#SYN-Flood泛洪攻击" class="headerlink" title="SYN Flood泛洪攻击"></a>SYN Flood泛洪攻击</h2><h3 id="什么是SYN-Flood攻击"><a href="#什么是SYN-Flood攻击" class="headerlink" title="什么是SYN Flood攻击"></a>什么是SYN Flood攻击</h3><p>SYN 泛洪（半开连接攻击）是一种拒绝服务(DDoS)攻击，旨在耗尽可用服务器资源，致使服务器无法传输合法流量。攻击者通过重复发送初始连接请求 (SYN) 数据包，可击垮目标服务器计算机上的所有可用端口，导致目标设备在响应正常业务流量时表现迟钝乃至全无响应。</p><h3 id="SYN-Flood攻击的原理"><a href="#SYN-Flood攻击的原理" class="headerlink" title="SYN Flood攻击的原理"></a>SYN Flood攻击的原理</h3><p>SYN泛洪攻击，是利用TCP连接的握手过程中的缺陷实现的。</p><p>攻击者通过发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，塞满TCP等待连接队列。</p><p><img src="https://www.cloudflare.com/img/learning/ddos/syn-flood-ddos-attack/syn-flood-attack-ddos-attack-diagram-2.png" alt="SYN Flood DDoS 攻击动画"></p><h3 id="防御SYN-Flood"><a href="#防御SYN-Flood" class="headerlink" title="防御SYN Flood"></a>防御SYN Flood</h3><h4 id="增大Nginx的并发限制"><a href="#增大Nginx的并发限制" class="headerlink" title="增大Nginx的并发限制"></a>增大Nginx的并发限制</h4><p>适度调整Nginx主配置文件中的<code> worker_rlimit_nofile</code> 和<code> worker_connections</code></p><p>可参考如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> root root;</span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>;</span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log logs/error.log notice;</span></span><br><span class="line"><span class="comment">#error_log logs/error.log info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid logs/nginx.pid;</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">        <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">        <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过<code>nginx -s reload</code>命令热重载Nginx配置文件</p><h4 id="调整系统TCP栈参数"><a href="#调整系统TCP栈参数" class="headerlink" title="调整系统TCP栈参数"></a>调整系统TCP栈参数</h4><p> 在sysctl配置文件中，调整如下参数可有效减轻SYN Flood攻击带来的损害。</p><ul><li><p><code>net.core.netdev_max_backlog</code></p><p>接受自网卡、但未被内核协议栈处理的报文队列长度</p></li><li><p><code>net.ipv4.tcp_max_syn_backlog</code></p><p>SYN_RCVD连接状态的最大个数</p></li><li><p><code>net.ipv4.tcp_abort_on_overflow</code></p><p>超出处理能力时，对新来的SYN直接回报RST，丢弃连接</p></li></ul><h4 id="增大linux的最大文件句柄数限制"><a href="#增大linux的最大文件句柄数限制" class="headerlink" title="增大linux的最大文件句柄数限制"></a>增大linux的最大文件句柄数限制</h4><p>使用<code> ulimit -n</code> 查看本系统的最大文件句柄数限制，默认是1024</p><p>可以通过修改<code> /etc/security/limts.conf</code>来改变该限制：</p><p>在文件的最后追加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 655360</span><br><span class="line">* hard nofile 655360</span><br></pre></td></tr></table></figure><p>最前面的<code>*</code>代表全局设置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常的连接数&quot;&gt;&lt;a href=&quot;#异常的连接数&quot; class=&quot;headerlink&quot; title=&quot;异常的连接数&quot;&gt;&lt;/a&gt;异常的连接数&lt;/h2&gt;&lt;p&gt;近日，镜像站莫名遭到多次攻击，症状表现为TCP连接数异常上升，久久得不到释放。后台监控检测到大量5XX错误，</summary>
      
    
    
    
    
    <category term="Cyberspace Security" scheme="http://example.com/tags/Cyberspace-Security/"/>
    
  </entry>
  
  <entry>
    <title>云场景下的网络QoS</title>
    <link href="http://example.com/2022/10/13/QoS/"/>
    <id>http://example.com/2022/10/13/QoS/</id>
    <published>2022-10-13T12:46:25.000Z</published>
    <updated>2022-12-24T14:59:34.257Z</updated>
    
    <content type="html"><![CDATA[<p>公共的网络链路总会不可避免的产生带宽抢占的问题，我们通常使用QoS技术保障大多数用户的服务质量。</p><p><img src="https://static001.geekbang.org/resource/image/74/11/747b0d537fd1705171ffcca3faf96211.jpg?wh=1539*646" alt="img"></p><p>一台服务器能控制的只有出方向的QoS，通过Shaping将出站流量整形，至于入栈流量只能通过Policy决定丢弃哪一部分数据包。</p><h2 id="队列方式控制网络QoS"><a href="#队列方式控制网络QoS" class="headerlink" title="队列方式控制网络QoS"></a>队列方式控制网络QoS</h2><p>Linux下的TC就主要是使用队列技术控制的网络QoS。</p><h3 id="无类别排队规则"><a href="#无类别排队规则" class="headerlink" title="无类别排队规则"></a>无类别排队规则</h3><p>不分类（或称无类别）排队规则（classless queueing disciplines）可以对某个网络 接口（interface）上的所有流量进行<strong>无差别整形</strong>。包括对数据进行：</p><ul><li>重新调度（reschedule）</li><li>增加延迟（delay）</li><li>丢弃（drop）</li></ul><p>与 classless qdisc 对应的是 classful qdisc，即有类别（或称分类别）排队规则。目前最常用的classless qdisc 是<strong>pfifo_fast</strong>，这也是很多系统上的 默认排队规则。</p><h5 id="pfifo-fast-先入先出队列"><a href="#pfifo-fast-先入先出队列" class="headerlink" title="pfifo_fast 先入先出队列"></a>pfifo_fast 先入先出队列</h5><p>如名字所示，这是一个先入先出(FIFO)队列，因此对所有的包都一视同仁。</p><p><img src="https://arthurchiao.art/assets/img/lartc-qdisc/pfifo_fast-qdisc.png" alt="img"></p><p>pfifo_fast有三个所谓的 “band”（可理解为三个队列），编号分别为 0、1、2：</p><p><img src="https://static001.geekbang.org/resource/image/e3/6c/e391b4b79580a7d66afe4307ff3f6f6c.jpg?wh=2037*1175" alt="img"></p><ul><li>每个band上分别执行 FIFO 规则。</li><li>如果band 0有数据，就不会处理band 1；同理，band 1有数据时，不会去处理band 2。</li><li>内核会检查数据包的 <code>TOS</code>字段，将“最小延迟”的包放到band 0。</li></ul><h5 id="Stochastic-Fair-Queuing-随机公平队列"><a href="#Stochastic-Fair-Queuing-随机公平队列" class="headerlink" title="Stochastic Fair Queuing (随机公平队列)"></a>Stochastic Fair Queuing (随机公平队列)</h5><p><img src="https://static001.geekbang.org/resource/image/b6/99/b6ec2e4e20ddee7d6952b7fa4586ba99.jpg?wh=2177*1182" alt="img"></p><p>这种无类别队列规则会建立很多的 FIFO 的队列，TCP Session 会计算 hash 值，通过 hash 值分配到某个队列。在队列的另一端，网络包会通过轮询策略从各个队列中取出发送。这样不会有一个 Session 占据所有的流量。</p><p>当然，如果两个 Session 的 hash 是一样的，会共享一个队列，也有可能互相影响。hash 函数会经常改变，从而 session 不会总是相互影响。</p><h5 id="Tolen-Bucket-Filte-TBF-令牌桶规则"><a href="#Tolen-Bucket-Filte-TBF-令牌桶规则" class="headerlink" title="Tolen Bucket Filte (TBF,令牌桶规则)"></a>Tolen Bucket Filte (TBF,令牌桶规则)</h5><p><img src="https://static001.geekbang.org/resource/image/14/9b/145c6f8593bf7603eae79246b9d6859b.jpg?wh=1894*1100" alt="img"></p><p>所有的网络包排成队列进行发送，但不是到了队头就能发送，而是需要拿到令牌才能发送。</p><p>令牌根据设定的速度生成，所以即便队列很长，也是按照一定的速度进行发送的。当没有包在队列中的时候，令牌还是以既定的速度生成，但是不是无限累积的，而是放满了桶为止。</p><p>设置桶的大小为了避免下面的情况：当长时间没有网络包发送的时候，积累了大量的令牌，突然来了大量的网络包，每个都能得到令牌，造成瞬间流量大增。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;公共的网络链路总会不可避免的产生带宽抢占的问题，我们通常使用QoS技术保障大多数用户的服务质量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/74/11/747b0d537fd1705171f</summary>
      
    
    
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>TCP状态机</title>
    <link href="http://example.com/2022/09/23/TCP/"/>
    <id>http://example.com/2022/09/23/TCP/</id>
    <published>2022-09-23T15:43:21.000Z</published>
    <updated>2022-12-24T15:02:08.561Z</updated>
    
    <content type="html"><![CDATA[<p>一个TCP连接在它的生命周期内会有不同的状态。</p><p>下图说明了TCP连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。</p><p><img src="https://upload-images.jianshu.io/upload_images/2846604-6a8557619966204d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>TCP状态及其描述如下表。</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>LISTEN</td><td>等待来自远程TCP应用程序的请求</td></tr><tr><td>SYN_SENT</td><td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td></tr><tr><td>SYN-RECEIVED</td><td>该端点已经接收到连接请求并发送确认。 该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td></tr><tr><td>ESTABLISHED</td><td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td></tr><tr><td>FIN_WAIT_1</td><td>等待来自远程TCP的终止连接请求或终止请求的确认</td></tr><tr><td>FIN_WAIT_2</td><td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td></tr><tr><td>CLOSE_WAIT</td><td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td></tr><tr><td>CLOSING</td><td>等待来自远程TCP的连接终止请求确认</td></tr><tr><td>LAST_ACK</td><td>等待先前发送到远程TCP的连接终止请求的确认</td></tr><tr><td>TIME_WAIT</td><td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td></tr></tbody></table><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>当一个TCP连接建立时，发生了以下事情：</p><ol><li>服务端必须准备接收传入的连接。这通常通过调用<code>socket</code>，<code>bind</code>和<code>listen</code>来完成，称为被动打开。</li><li>客户端通过调用<code>connect</code>方法来发起一个主动的打开。客户端TCP会发送一个“同步”(SYN)段，它告诉服务器客户端在连接上发送的数据的初始序列号。通常情况下，SYN没有发送数据，它只包含一个IP头，TCP头和可能的TCP选项。</li><li>服务器必须确认（ACK）客户端的SYN，并且服务器还必须发送自己的SYN，其中包含服务器将在连接上发送的数据的初始序列号。</li><li>客户端必须确认服务器的SYN。</li></ol><p>下图显示了TCP三次握手的过程，以及客户端和服务端状态的变化。</p><p><img src="https://upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>一个TCP连接需要四步断开：</p><ol><li>一个应用程序首先执行<code>close</code>，发送FIN段，这个操作被称为主动关闭，这意味着这一端完成数据的发送。</li><li>执行FIN的另一端执行被动关闭，该端发送ACK，确认该FIN。</li><li>被动关闭的一端执行<code>close</code>，向主动关闭的一方发送FIN。</li><li>主动关闭的一方确认收到的FIN。</li></ol><p>下图显示了一次典型的TCP四次挥手的过程，以及主动关闭方和被动关闭方的状态变化。在图中是客户端主动断开了连接，这里只是举个例子，服务端一样可以主动断开连接。</p><p><img src="https://upload-images.jianshu.io/upload_images/2846604-9677c82f02e126f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h2 id="关于TIME-WAIT状态"><a href="#关于TIME-WAIT状态" class="headerlink" title="关于TIME_WAIT状态"></a>关于TIME_WAIT状态</h2><p>TIME_WAIT状态应该是最让人疑惑的一个状态了。在上图中可以看到，执行主动断开的节点最后会进入这个状态，该节点会在此状态保存2倍的MSL（最大段生存期）。</p><p>TCP的每个实现都必须为MSL选择一个值。RFC 1122推荐的值为两分钟，伯克利派的实现使用30秒。这也就是说TIME_WAIT状态会维持1到4分钟。MSL是任何IP数据报可以在网络中生存的最长时间。这个时间是有限制的，因为每个数据报都包含一个8位的跳数限制，最大值是255.虽然这是一个跳数限制而不是一个真正的时间限制，但是根据这个限制来假设数据报的最长生命周期依然是有意义的。</p><p>网络中数据报丢失的原因通常是路由异常。一旦路由崩溃或者两个路由之间的链路断开，路由协议需要几秒或几分钟才能稳定，并找到一条备用路径。在这段时间内，可能发生路由回路。同时假设丢失是一个TCP数据报，则发生TCP超时，并且重新发送分组，重传的分组通过一些备用路径达到最终目的地。但是一段时间后（该时间小于MSL），路由循环被更正，在循环中丢失的数据报被发送到最终目的地。这个原始的数据报被称为丢失的副本或漫游副本。TCP协议必须处理这些数据报。</p><p>维持TIME_WAIT有两个原因：</p><ol><li>可靠地实现TCP的全双工连接终止。</li><li>允许旧的重复数据段在网络中过期</li></ol><p>在四次挥手中，假设最后的ACK丢失了，被动关闭方会重发FIN。主动关闭端必须维护状态，来允许被动关闭方重发最后的ACK；如果它没有维护这个状态，将会对重发FIN返回RST，被动关闭方会认为这是个错误。如果TCP正在执行彻底终止数据流的两个方向所需的所有工作（即全双工关闭），则必须正确处理这四个段中任何一个的丢失。所以执行主动关闭的一方必须在结束时保持TIME_WAIT状态：因为它可能必须重传最后的ACK。</p><p>现在来聊维持TIME_WAIT状态的第二个原因。假设在主机12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。此连接关闭后，在相通的地址和端口建立了另外一个连接。由于IP地址和端口相同，所以后一种连接被称为先前连接的“化身”。TCP必须防止连接中的旧副本在稍后再次出现，并被误解为属于同一连接的新“化身”。为此，TCP将不会启动当前处于TIME_WAIT状态的连接的新“化身”。由于TIME_WAIT状态的持续时间时两倍的MSL，因此TCP允许一个方向的数据在MSL秒内丢失，也允许回复在一个MSL秒内丢失。通过强制执行此规则，可以保证当一个TCP连接成功建立时，来自先前连接的所有旧的副本在网络中已过期。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个TCP连接在它的生命周期内会有不同的状态。&lt;/p&gt;
&lt;p&gt;下图说明了TCP连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jiansh</summary>
      
    
    
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
</feed>
