<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aethoce&#39;s Blog</title>
  
  <subtitle>为开放自由的互联网做点微小的贡献</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-13T01:14:16.822Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jinghong Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能计算-基准测试程序Linpack（HPL）</title>
    <link href="http://example.com/2022/12/11/HPL/"/>
    <id>http://example.com/2022/12/11/HPL/</id>
    <published>2022-12-11T02:48:16.705Z</published>
    <updated>2022-12-13T01:14:16.822Z</updated>
    
    <content type="html"><![CDATA[<p>自通用计算机时代开始以来，就出现了各种用于评估计算机性能的基准测试程序。这些程序的性质通常反映了构建计算机的预期目的，同时还提供了可以与制造商的理论性能估计进行比较的经验性能测量。</p><p>高性能计算中最广泛使用的基准之一就是Linpack基准，它的起源是一个线性代数运算包，后来被Lapack库和其他竞争对手取代。但Linpack的基准测试程序在以后的日子里继续发挥强大的影响力。</p><p>HPL，即(High-Performance <em>Linpack</em>)是早期Linpack的衍生产品，其高度并行化的设计，使得它用于评估TOP500超级计算机的性能排名。</p><h2 id="编译安装HPL"><a href="#编译安装HPL" class="headerlink" title="编译安装HPL"></a>编译安装HPL</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>在安装HPL之前，系统上需要安装好支持C语言和Fortran77语言的编译器，我个人选择使用gcc与gfortran ，我将用他们来安装BLAS、MPICH以及HPL本体。</p><h4 id="BLAS"><a href="#BLAS" class="headerlink" title="BLAS"></a>BLAS</h4><p>到<a href="http://www.netlib.org/blas/">BLAS官网</a>下载好源码，使用tar指令解压。进入BLAS文件夹，执行编译指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gfortran -c -O3 *.f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译所有的 .f 文件，生成 .o文件</span></span><br><span class="line"> </span><br><span class="line">ar rv libblas.a *.o  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">链接所有的 .o文件，生成.a 文件</span></span><br><span class="line"> </span><br><span class="line">cp libblas.a /usr/local/lib  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将库文件复制到系统库目录</span></span><br></pre></td></tr></table></figure><h4 id="MPICH"><a href="#MPICH" class="headerlink" title="MPICH"></a>MPICH</h4><p>到<a href="https://www.mpich.org/downloads/">MPICH官网</a>下载源码包，使用tar指令解压。进入mpich文件夹进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/software/mpich-4.0.3</span><br></pre></td></tr></table></figure><p>然后<code>make&amp;&amp;make install</code>完成安装。</p><p>记得编辑<code>.bashrc</code>以配置环境变量。可参考下方配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># mpich</span><br><span class="line"></span><br><span class="line">export MPI_HOME=/home/software/mpich-4.0.3</span><br><span class="line"></span><br><span class="line">export PATH=$MPI_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$MPI_HOME/include</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MPI_HOME/lib</span><br><span class="line"></span><br><span class="line">export MANPATN=$MANPATH:$MPI_HOME/man</span><br></pre></td></tr></table></figure><p>最后激活环境变量即可使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><h4 id="HPL"><a href="#HPL" class="headerlink" title="HPL"></a>HPL</h4><p>于<a href="https://netlib.org/benchmark/hpl/">HPL官网</a>下载源码包，使用<code>tar</code>指令解压后进入其<code>setup</code>目录。</p><p>手写Make文件是一件痛苦的事情，好在这里有一些针对各种体系结构的编译设置实例。对于此实例，我们需要执行<code>make_generic</code>脚本以生成用于创建编译设置的模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd hpl-2.3/setup</span><br><span class="line">sh make_generic</span><br><span class="line">cp Make.UNKNOWN ..Make.linux</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>现在，我们需要修改<code>Make.linux</code>文件，以声明hpl2.3目录以及BLAS库的位置.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 LAlib= -lblas</span><br></pre></td></tr></table></figure><p>使用-L标志为编译器提供库位置，例如我的BLAS库安装在<code>/usr/local/lib</code>中，则将97行更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 LAlib= -L/usr/local/lib -lblas</span><br></pre></td></tr></table></figure><p>另外在第70行指定<code>hpl-2.3</code>目录的位置，在64行将架构体系的名称从UNKNOWN改为linux</p><p>准备好<code>Make.linux</code>文件后，发出以下指令来编译HPL。</p><p><code>make arch=linux</code></p><p>这将在<code>bin/linux</code>目录里创建HPL的可执行文件xhpl。</p><h3 id="调试HPL参数文件"><a href="#调试HPL参数文件" class="headerlink" title="调试HPL参数文件"></a>调试HPL参数文件</h3><p>伴随<code>xhpl</code>可执行文件的是一个参数文件(HPL.dat)，用于调整HPL的计算参数。</p><p>下面给出一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">HPLinpack benchmark input file</span><br><span class="line">Innovative Computing Laboratory, University of Tennessee</span><br><span class="line">HPL.out      output file name (if any)</span><br><span class="line">6            device out (6=stdout,7=stderr,file)</span><br><span class="line">1            # of problems sizes (N)</span><br><span class="line">143360 256000 1000         Ns  </span><br><span class="line">1            # of NBs</span><br><span class="line">384 192 256      NBs </span><br><span class="line">1            PMAP process mapping (0=Row-,1=Column-major)</span><br><span class="line">1            # of process grids (P x Q)</span><br><span class="line">1 2          Ps  </span><br><span class="line">1 2          Qs  </span><br><span class="line">16.0         threshold</span><br><span class="line">1            # of panel fact</span><br><span class="line">2 1 0        PFACTs (0=left, 1=Crout, 2=Right)</span><br><span class="line">1            # of recursive stopping criterium</span><br><span class="line">2            NBMINs (&gt;= 1)</span><br><span class="line">1            # of panels in recursion</span><br><span class="line">2            NDIVs</span><br><span class="line">1            # of recursive panel fact.</span><br><span class="line">1 0 2        RFACTs (0=left, 1=Crout, 2=Right)</span><br><span class="line">1            # of broadcast</span><br><span class="line">0            BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM)</span><br><span class="line">1            # of lookahead depth</span><br><span class="line">0            DEPTHs (&gt;=0)</span><br><span class="line">0            SWAP (0=bin-exch,1=long,2=mix)</span><br><span class="line">1            swapping threshold</span><br><span class="line">1            L1 in (0=transposed,1=no-transposed) form</span><br><span class="line">1            U  in (0=transposed,1=no-transposed) form</span><br><span class="line">0            Equilibration (0=no,1=yes)</span><br><span class="line">8            memory alignment in double (&gt; 0)</span><br></pre></td></tr></table></figure><p>测试过程中您可以根据节点的硬件配置，调整HPL.dat文件中相关参数，参数的说明如下所示。</p><ul><li><p>第5~6行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1            # of problems sizes (N)，N表示求解的矩阵数量与规模</span><br><span class="line">143360 256000 1000         Ns  </span><br></pre></td></tr></table></figure><p>N表示求解的矩阵数量与规模。矩阵规模N越大，有效计算所占的比例也越大，系统浮点处理性能也就越高。但矩阵规模越大会导致内存消耗量越多，如果系统实际内存空间不足，使用缓存、性能会大幅度降低。矩阵占用系统总内存的80%左右为最佳，即N×N×8&#x3D;系统总内存×80%（其中总内存的单位为字节）。</p></li><li><p>第7~8行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1            # of NBs，NB表示求解矩阵过程中矩阵分块的大小</span><br><span class="line">384 192 256      NBs </span><br></pre></td></tr></table></figure><p>求解矩阵过程中矩阵分块的大小。分块大小对性能有很大的影响，NB的选择和软硬件许多因素密切相关。NB值的选择主要是通过实际测试得出最优值，一般遵循以下规律：</p><ul><li>NB不能太大或太小，一般小于384。</li><li>NB×8一定是缓存行的倍数。</li><li>NB的大小和通信方式、矩阵规模、网络、处理器速度等有关系。</li></ul><p>一般通过单节点或单CPU测试可以得到几个较好的NB值，但当系统规模增加、问题规模变大，有些NB取值所得性能会下降。因此建议在小规模测试时选择3个性能不错的NB值，再通过大规模测试检验这些选择。</p></li><li><p>第10~12行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1            # of process grids (P x Q)，P表示水平方向处理器个数，Q表示垂直方向处理器个数</span><br><span class="line">1 2          Ps  </span><br><span class="line">1 2          Qs  </span><br></pre></td></tr></table></figure><p>P表示水平方向处理器个数，Q表示垂直方向处理器个数。P×Q表示二维处理器网格。P×Q&#x3D;系统CPU数&#x3D;进程数。一般情况下一个进程对应一个CPU，可以得到最佳性能。对于Intel ® Xeon ®，关闭超线程可以提高HPL性能。P和Q的取值一般遵循以下规律：</p><ul><li>P≤Q，一般情况下P的取值小于Q，因为列向通信量（通信次数和通信数据量）要远大于横向通信。</li><li>P建议选择2的幂。HPL中水平方向通信采用二元交换法（Binary Exchange），当水平方向处理器个数P为2的幂时性能最优。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自通用计算机时代开始以来，就出现了各种用于评估计算机性能的基准测试程序。这些程序的性质通常反映了构建计算机的预期目的，同时还提供了可以与制造商的理论性能估计进行比较的经验性能测量。&lt;/p&gt;
&lt;p&gt;高性能计算中最广泛使用的基准之一就是Linpack基准，它的起源是一个线性代数</summary>
      
    
    
    
    
    <category term="High Performance Computing" scheme="http://example.com/tags/High-Performance-Computing/"/>
    
  </entry>
  
</feed>
