---
title: TCP状态机
cover: https://s2.loli.net/2022/12/24/FI1YkGehQyVKs9T.jpg
tags: Computer Network
date: 2022/9/23 23:43:21
---

一个TCP连接在它的生命周期内会有不同的状态。

下图说明了TCP连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。

![img](https:////upload-images.jianshu.io/upload_images/2846604-6a8557619966204d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

TCP状态及其描述如下表。

| 状态         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| LISTEN       | 等待来自远程TCP应用程序的请求                                |
| SYN_SENT     | 发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态 |
| SYN-RECEIVED | 该端点已经接收到连接请求并发送确认。 该端点正在等待最终确认。TCP第二次握手后服务端所处的状态 |
| ESTABLISHED  | 代表连接已经建立起来了。这是连接数据传输阶段的正常状态       |
| FIN_WAIT_1   | 等待来自远程TCP的终止连接请求或终止请求的确认                |
| FIN_WAIT_2   | 在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求    |
| CLOSE_WAIT   | 该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求 |
| CLOSING      | 等待来自远程TCP的连接终止请求确认                            |
| LAST_ACK     | 等待先前发送到远程TCP的连接终止请求的确认                    |
| TIME_WAIT    | 等待足够的时间来确保远程TCP接收到其连接终止请求的确认        |

## TCP三次握手

当一个TCP连接建立时，发生了以下事情：

1. 服务端必须准备接收传入的连接。这通常通过调用`socket`，`bind`和`listen`来完成，称为被动打开。
2. 客户端通过调用`connect`方法来发起一个主动的打开。客户端TCP会发送一个“同步”(SYN)段，它告诉服务器客户端在连接上发送的数据的初始序列号。通常情况下，SYN没有发送数据，它只包含一个IP头，TCP头和可能的TCP选项。
3. 服务器必须确认（ACK）客户端的SYN，并且服务器还必须发送自己的SYN，其中包含服务器将在连接上发送的数据的初始序列号。
4. 客户端必须确认服务器的SYN。

下图显示了TCP三次握手的过程，以及客户端和服务端状态的变化。

![img](https:////upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## TCP四次挥手

一个TCP连接需要四步断开：

1. 一个应用程序首先执行`close`，发送FIN段，这个操作被称为主动关闭，这意味着这一端完成数据的发送。
2. 执行FIN的另一端执行被动关闭，该端发送ACK，确认该FIN。
3. 被动关闭的一端执行`close`，向主动关闭的一方发送FIN。
4. 主动关闭的一方确认收到的FIN。

下图显示了一次典型的TCP四次挥手的过程，以及主动关闭方和被动关闭方的状态变化。在图中是客户端主动断开了连接，这里只是举个例子，服务端一样可以主动断开连接。

![img](https:////upload-images.jianshu.io/upload_images/2846604-9677c82f02e126f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## 关于TIME_WAIT状态

TIME_WAIT状态应该是最让人疑惑的一个状态了。在上图中可以看到，执行主动断开的节点最后会进入这个状态，该节点会在此状态保存2倍的MSL（最大段生存期）。

TCP的每个实现都必须为MSL选择一个值。RFC 1122推荐的值为两分钟，伯克利派的实现使用30秒。这也就是说TIME_WAIT状态会维持1到4分钟。MSL是任何IP数据报可以在网络中生存的最长时间。这个时间是有限制的，因为每个数据报都包含一个8位的跳数限制，最大值是255.虽然这是一个跳数限制而不是一个真正的时间限制，但是根据这个限制来假设数据报的最长生命周期依然是有意义的。

网络中数据报丢失的原因通常是路由异常。一旦路由崩溃或者两个路由之间的链路断开，路由协议需要几秒或几分钟才能稳定，并找到一条备用路径。在这段时间内，可能发生路由回路。同时假设丢失是一个TCP数据报，则发生TCP超时，并且重新发送分组，重传的分组通过一些备用路径达到最终目的地。但是一段时间后（该时间小于MSL），路由循环被更正，在循环中丢失的数据报被发送到最终目的地。这个原始的数据报被称为丢失的副本或漫游副本。TCP协议必须处理这些数据报。

维持TIME_WAIT有两个原因：

1. 可靠地实现TCP的全双工连接终止。
2. 允许旧的重复数据段在网络中过期

在四次挥手中，假设最后的ACK丢失了，被动关闭方会重发FIN。主动关闭端必须维护状态，来允许被动关闭方重发最后的ACK；如果它没有维护这个状态，将会对重发FIN返回RST，被动关闭方会认为这是个错误。如果TCP正在执行彻底终止数据流的两个方向所需的所有工作（即全双工关闭），则必须正确处理这四个段中任何一个的丢失。所以执行主动关闭的一方必须在结束时保持TIME_WAIT状态：因为它可能必须重传最后的ACK。

现在来聊维持TIME_WAIT状态的第二个原因。假设在主机12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接。此连接关闭后，在相通的地址和端口建立了另外一个连接。由于IP地址和端口相同，所以后一种连接被称为先前连接的“化身”。TCP必须防止连接中的旧副本在稍后再次出现，并被误解为属于同一连接的新“化身”。为此，TCP将不会启动当前处于TIME_WAIT状态的连接的新“化身”。由于TIME_WAIT状态的持续时间时两倍的MSL，因此TCP允许一个方向的数据在MSL秒内丢失，也允许回复在一个MSL秒内丢失。通过强制执行此规则，可以保证当一个TCP连接成功建立时，来自先前连接的所有旧的副本在网络中已过期。